## 1. Linux开机启动

- 内核实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过内核传达给硬件。

- 狭义的操作系统就是指内核，广义的操作系统包括内核以及内核之上的各种应用。

- 内核会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，内核会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，内核就完成了在计算机启动阶段的工作，交接给init来管理。

- 随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：
设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……
当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录。init会给出登录(login)对话框，或者是图形化的登录界面。

- 总结:BIOS -> MBR(加载引导程序) -> 引导加载程序 -> 内核 -> init process -> login

## 2. Linux文件系统

- 目录也是一种文件，这个文件中至少包含有以下条目`.和..`

- 当删除原始文件f1后，硬连接f2不受影响，但是符号连接f1文件无效。硬连接指通过索引节点来进行连接，它们的Inode是一样的。默认ln是硬链接。软链接其实就是快捷方式。

- 文件权限，umask等

## 3. Linux架构


![linux架构.jpeg](http://upload-images.jianshu.io/upload_images/4097708-9ab5bd18de52cf36.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 为了方便调用内核，Linux将内核的功能接口制作成系统调用(system call)。

- Linux定义一些库函数(library routine)来将系统调用组合成某些常用的功能。

## 4. Linux文件管理相关命令

- chown 意思是change owner

- chgrp 意思是change group

- fork通常作为一个函数被调用。这个函数会有两次返回，将子进程的PID返回给父进程，0返回给子进程。实际上，子进程总可以查询自己的PPID来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。

- 尽管在UNIX中，进程与线程是有联系但不同的两个东西，但在Linux中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和IO接口。所以，进程是Linux程序的唯一的实现方式。

- 如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。

## 5. Linux信号基础

- 信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用。信号因此被经常地用于系统管理相关的任务，比如通知进程终结、中止或者恢复等等。

## 6. Linux进程关系

- 每个进程都有父进程，而所有的进程以init进程为根

- 每个进程都会属于一个进程组(process group)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程 (process group leader)，领导进程的PID (PID见Linux进程基础)成为进程组的ID (process group ID, PGID)，以识别进程组。

- exec 的作用，是装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务。这是对当前进程的操作。
如果直接执行 exec 的话，当前进程就完全换掉了。所以要先 fork，然后再于子进程里执行 exec。

- 我们将一些进程归为进程组的一个重要原因是我们可以将信号发送给一个进程组。进程组中的所有进程都会收到该信号。

- 会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。

## 7. Linux从程序到进程

- 每次执行程序时

- Text区域用来储存指令(instruction)，说明每一步的操作。Global Data用于存放全局变量，栈(Stack)用于存放局部变量，堆(heap)用于存放动态变量 (dynamic variable. 程序利用malloc系统调用，直接从内存中为dynamic variable开辟空间)。Text和Global data在进程一开始的时候就确定了，并在整个进程中保持固定大小。

- 栈(Stack)以帧(stack frame)为单位。当程序调用函数的时候，比如main()函数中调用inner()函数，stack会向下增长一帧。帧中存储该函数的参数和局部变量，以及该函数的返回地址(return address)。

- 当程序中使用malloc的时候，堆(heap)会向上增长，其增长的部分就成为malloc从内存中分配的空间。malloc开辟的空间会一直存在，直到我们用free系统调用来释放，或者进程结束。一个经典的错误是内存泄漏(memory leakage), 就是指我们没有释放不再使用的堆空间，导致堆不断增长，而内存可用空间不断减少。

## 8. Linux多线程和同步

- 多线程就是允许一个进程内存在多个控制权，以便让多个函数同时处于激活状态，从而让多个函数的操作同时运行。即使是单CPU的计算机，也可以通过不停地在不同线程的指令间切换，从而造成多线程同时运行的效果。

- 创建一个新的线程时，我们为这个线程建一个新的栈。每个栈对应一个线程。

- 最常见的解决竞争条件的方法是将原先分离的两个指令构成不可分隔的一个原子操作(atomic operation)

### 多线程同步

- 互斥锁是一个特殊的变量，它有锁上(lock)和打开(unlock)两个状态。互斥锁一般被设置成全局变量。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开。

- 如果一个锁被一个线程获得W锁，那么其它线程，无论是想要获取R锁还是W锁，都必须等待该线程释放W锁。
这样，多个线程就可以同时读取共享资源。而具有危险性的写入操作则得到了互斥锁的保护。

## 9. Linux进程间通信

- PIPE（管道）

- 
消息队列(message queue)，信号量(semaphore)，共享内存(shared memory)。这些IPC的特点是允许多进程之间共享资源，这与多线程共享heap和global data相类似。

## 10. Linux文件系统的实现

- Linux的分区是挂载在同一个文件系统树上。

- 分区的第一个部分是启动区(Boot block)，它主要是为计算机开机服务的。Linux开机启动后，会首先载入MBR，随后MBR从某个硬盘的启动区加载程序。该程序负责进一步的操作系统的加载和启动。为了方便管理，即使某个分区中没有安装操作系统，Linux也会在该分区预留启动区。

- 启动区之后的是超级区(Super block)。它存储有文件系统的相关信息，包括文件系统的类型，inode的数目，数据块的数目。

- 随后是多个inodes，它们是实现文件存储的关键。在Linux系统中，一个文件可以分成几个数据块存储，就好像是分散在各地的龙珠一样。为了顺利的收集齐龙珠，我们需要一个“雷达”的指引：该文件对应的inode。每个文件对应一个inode。这个inode中包含多个指针，指向属于该文件各个数据块。当操作系统需要读取文件时，只需要对应inode的"地图"，收集起分散的数据块，就可以收获我们的文件了。
